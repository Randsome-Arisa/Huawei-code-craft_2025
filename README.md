*任务书* 和 *样例数据说明* 这两个 PDF 转成了 TXT 格式，方便上传给 AI 进行解析处理。

# 题目理解
## 符号含义
| 符号  | 含义                |
| --- | ----------------- |
| T   | 共T+105个时间片        |
| M   | 对象标签种数            |
| N   | 硬盘数               |
| V   | 每个硬盘的存储单元数        |
| G   | 每个时间片每个磁头最多消耗的令牌数 |

- 每块硬盘有 V 个 *存储单元*，每个存储单元可以存一个 *对象块*；
- 尽量顺序存储；
- 任何时间存储系统中空余的存储单元数占总存储单元数的至少 10%；
- 删除越多的越应该优先读（否则可能读一半被删导致没分）；
- 写入阶段需要在该时间片处理所有的写入请求；
- $1≤𝑜𝑏𝑗_𝑠𝑖𝑧𝑒[𝑖]≤5$，说明都是小对象。远小于磁盘的 5000。
# 优化方向
## 写优化
避免碎片化，负载均衡。
### 分配算法优化
第一版：First Fit 算法。
第二版：分离空闲链表。
### 磁盘选择算法优化
第一版：$(id+j)\%N$ 选择磁盘。 
第二版：可用连续空间最空闲调度。
- 尽量选择空闲的
- 尽量选择与该对象同标签少的磁盘
	在 *越相近的标签越容易同时被请求* 的前提下有利于并行读取，因为假设请求1读取在磁盘1、2、3上的标签为1的对象1，请求2也读取标签为1的对象2，如果对象2也在1、2、3磁盘上，需要读完对象1再读对象2，如果对象2在磁盘4、5、6上，就可以并行读了。
## 读优化
### 读调度算法优化
- 优先读取当前磁头右边距离最近的对象块的读请求。即移动磁头成本最低的，这也有利于之后的顺序读取。
> 注意读取的单位不是对象，而是对象块，因此优先队列存储的应该是每个待读对象块的距离成本。
- 优先读取即将被删除的对象，避免拿不到分。
- 优先读取即将完成的对象。优先读取size比较大的对象。
	贪心策略，尽量把能拿到的分拿到。

想到一个“大方”算法，核心思路是综合考虑一些请求后再行动，具体做法如下：
如果读取请求队列不是很大，在收到读请求后不立即去读数据，而是计算这次读数据的成本，如果必须jump才能到达读取点的话就不做任何处理，只是将该请求加入队列。在有一些请求综合考虑后再去行动。这个阈值可以根据最大请求数进行调整。